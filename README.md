# Signature-based-and-Image-based-Malware-Detection-System


## Developed by : 
  #### Hayoun Fatima Zohra
  !! your names !!
                                                                                                                            


# Table of Contents
- [Introduction](#Introduction)
- [Tools](#Tools)
- [Models training](#Model_training)
- [User Interface](#User_Interface)
- [Conclusion](#Conclusion)

# Introduction : 

In this project, we emphasize a hands-on approach where we will search for datasets containing both image and signature malware samples. and we will follow a structured machine learning pipeline, including data preprocessing, training multiple models, and evaluating their performance using metrics such as accuracy, precision, recall, and F1-score. By integrating MLOps practices throughout the process, for gaining valuable experience in managing the lifecycle of machine learning models in cybersecurity applications.

# Tools :
</br>

<img src="https://github.com/Youssefouaaqa/Signature-based-and-Image-based-Malware-Detection-System/assets/128602766/612cf9a0-574d-4441-a11a-0ad98a3c5899" alt="Angular" width="200" align="left" style="margin-right: 15px;" /><strong>Angular :</strong> Angular is a TypeScript-based open-source front-end web application framework. It is used for building dynamic single-page applications (SPAs) where content is loaded dynamically without the need for full-page reloads.</br></br>





</br></br>


<img src="https://github.com/Youssefouaaqa/Signature-based-and-Image-based-Malware-Detection-System/assets/128602766/f42cd2c8-eb1c-4c8f-9cab-e396399d9438" alt="MLops" width="200" align="left" style="margin-right: 15px;" />
 <strong>MLOps:</strong> MLOps, short for Machine Learning Operations, is the practice of integrating machine learning (ML) models into the software development lifecycle (SDLC). It aims to streamline the deployment, monitoring, and management of ML models in production environments.</br></br>
  






</br></br>

<img src="https://github.com/Youssefouaaqa/Signature-based-and-Image-based-Malware-Detection-System/assets/128602766/01100a7c-e06f-4af7-aef1-4c45e117aaf0" alt="CICD" width="200" align="left" style="margin-right: 15px;" />
<strong>GitHub (CI/CD): </strong>GitHub is a platform for hosting and sharing code repositories. CI/CD (Continuous Integration/Continuous Deployment) is a set of practices used to automate the process of integrating code changes into a shared repository (CI) and deploying code to production environments (CD) after passing automated tests.
</br></br>
</br></br>
<img src="https://github.com/Youssefouaaqa/Signature-based-and-Image-based-Malware-Detection-System/assets/128602766/288cd02d-7e62-461c-b41f-82fbecaa5163" alt="Angular" width="200" align="left" style="margin-right: 15px;" />
<strong>Scikit-learn (sklearn): </strong> Scikit-learn is an open-source machine learning library for Python. It provides simple and efficient tools for data mining and data analysis, built on NumPy, SciPy, and matplotlib. Scikit-learn features various classification, regression, and clustering algorithms, including support for model evaluation and data preprocessing. It is designed to interoperate with other Python libraries such as NumPy and pandas.</br></br>
</br></br>

# Models training :
## Signature based model
To train this model, we looked for a detailed dataset and we found one that containes PE file headers of diffrent legitimate and malwared files.
### Model Training
#### Step-by-Step Explanation
1. Data Loading and Initial Preparation
   - Load the dataset from a CSV file.
   - Rename columns for better readability.
   - Check the initial few rows, shape, and statistical description of the dataset.
   - Check for null values and remove duplicates.
2. Data Exploration and Visualization
   - Analyze the class distribution of the target variable (legitimate).
   - Visualize the class distribution using a bar plot.
3. Feature Selection
   - Drop unnecessary columns (Name, md5, legitimate).
   - Fit an ExtraTreesClassifier to identify important features.
   - Select important features based on the feature importances from the classifier.
4. Data Scaling
   - Apply standard scaling to the selected features to normalize the data.
5. Handling Class Imbalance
   - Use SMOTE (Synthetic Minority Over-sampling Technique) to balance the training data.
6. Model Training and Evaluation
   - Initialize three different models: Decision Tree, Random Forest, and XGBoost.
   - Perform cross-validation to evaluate the performance of each model.
   - Select the best model based on cross-validation scores.
   - Train the selected models on the training data and evaluate them on the test data.
   - Select the best performing model based on test data accuracy.
7. Saving the Model
   - Save the best model and the selected features using joblib and pickle.
  ### Extracting PE Headers
  To extract PE (Portable Executable) headers, we use the 'pefile' library, which allows us to parse PE files and extract relevant features.
  #### Functions for Extraction
  1. Entropy Calculation
     Calculates the entropy of data, which measures the randomness. Higher entropy indicates more randomness.
2. Resource Extraction
   Extracts resources from the PE file and calculates their entropy and size.
3. Version Info Extraction
   Extracts version information from the PE file.
4. Main Extraction Function
  Combines all the above functions to extract comprehensive information from the PE file.
  - the targeted pe headers:
    1. feature DllCharacteristics
    2. feature Characteristics
    3. feature Machine
    4. feature SectionsMaxEntropy
    5. feature Subsystem
    6. feature VersionInformationSize
    7. feature ImageBase
    8. feature MajorSubsystemVersion
    9. feature SizeOfOptionalHeader
    10. feature ResourcesMinEntropy
    11. feature ResourcesMaxEntropy
    12. feature SizeOfStackReserve
    13. feature MajorOperatingSystemVersion
    - to view the code look at the extract_PE_headers.py file
    
  ## Image based model

In our project, we're using machine learning to improve malware detection. We train our models in two ways: one, by looking at the unique signatures or patterns of known malware, and two, by analyzing the visual characteristics of malware samples converted into images. This dual approach helps us build a more effective system for identifying and classifying malware, even if it's never been seen before.

</br> 

### images data :


In this section, we describe the process of training machine learning models using the dataset containing images of malware and non-malware samples. We focus on two popular classifiers, Random Forest and Support Vector Machine (SVM), to classify the images and evaluate their performance.

</br>

#### using SVM :

<strong>SVM</strong>, or <strong>Support Vector Machine</strong>, is a supervised machine learning algorithm commonly employed for tasks involving classification and regression. It operates by identifying the hyperplane that most effectively segregates distinct classes within the feature space. We selected SVM for this project due to its 
effectiveness in determining whether an image represents malware or benign content.


At first, We collected a dataset consisting of images of malware and non-malware images. The images were preprocessed to extract relevant features using the Histogram of Oriented Gradients (HOG) method. The HOG method was chosen for its ability to capture important features from images. It converts images into histograms of gradient orientations, which are then used as input features for training the SVM model.


then The dataset was split into training and validation sets. To address class imbalance, we used the Synthetic Minority Over-sampling Technique (SMOTE) to generate synthetic samples of the minority class. The features were standardized using StandardScaler before training the SVM model.


After all, We evaluated the performance of the SVM model using metrics such as accuracy, precision, recall, F1-score, and ROC AUC.And We utilized MLflow to track the training process and log important metrics, parameters, and artifacts.


At the end The best-performing SVM model was saved using joblib for potential deployment in a production environment. Considerations for model deployment, such as 
scalability and reliability, were also discussed.</br>


#### using random Forest :

</br>

# User Interface
</br>

# conclusion :

</br>

In conclusion, this project successfully implemented a malware detection system using machine learning techniques. By extracting features from images and training a Random Forest classifier, we were able to achieve effective detection of malware. The use of SMOTE to address class imbalance and MLflow for experiment tracking and model management further enhanced the project's robustness and scalability. Overall, this project highlights the potential of machine learning in cybersecurity and provides a solid foundation for future research and development in this field.


